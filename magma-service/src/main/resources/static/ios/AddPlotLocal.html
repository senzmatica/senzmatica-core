<!DOCTYPE html>
<html>
<head>
    <title>Simple Map</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        #map {
            height: 100%;
        / / padding-bottom: 25 px;
        / / added to hide google copyright info in the map
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #choose-panel {
            position: absolute;
            top: 35%;
            left: 17px;
            right: 17px;
            z-index: 5;
            background: #FFFFFF 0% 0% no-repeat padding-box;
            padding: 5px;
            border: 1px solid #F0F0F1;
            border-radius: 8px;
            box-shadow: 0.75px 3px 6px #00000029;
            text-align: left;
            font-family: 'Poppins', 'sans-serif';
            justify-content: center;
        }

        #manual-measuring-panel {
            position: absolute;
            bottom: 0px;
            left: 0px;
            right: 0px;
            z-index: 5;
            padding: 5px;
            background-color: #fff;
            border-radius: 15px 15px 0px 0px;
            text-align: center;
            font-family: 'Roboto', 'sans-serif';
            line-height: 30px;
        }

        .triple-options-panel {
            z-index: 5;
            padding: 5px;
            text-align: center;
            font-family: 'Roboto', 'sans-serif';
            line-height: 30px;
        }

        .green-button-with-text {
            background: #22C674 0% 0% no-repeat padding-box;
            padding: 5px;
            margin-left: 16px;
            margin-right: 16px;
            margin-bottom: 10px;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            flex-direction: row;
            justify-content: center;
            align-items: center;
        }

        #gps-panel {
            position: absolute;
            bottom: 0px;
            left: 0px;
            right: 0px;
            z-index: 5;
            padding: 5px;
            background-color: #fff;
            border-radius: 15px 15px 0px 0px;
            text-align: center;
            font-family: 'Roboto', 'sans-serif';
            line-height: 30px;
        }

        #pin-location-button {
            background: #22C674 0% 0% no-repeat padding-box;
            margin: 5px;
            padding: 5px;
            margin-bottom: 10px;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            justify-content: center;
            align-items: center;
        }

        #confirm-button {
            margin: 5px;
            padding: 5px;
            margin-bottom: 10px;
            border: 2px solid #22C674;
            background: #FFFFFF 0% 0% no-repeat padding-box;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            justify-content: center;
            align-items: center;
        }

        #auto-gps-panel {
            position: absolute;
            bottom: 0px;
            left: 0px;
            right: 0px;
            z-index: 5;
            padding: 5px;
            background-color: #fff;
            border-radius: 15px 15px 0px 0px;
            text-align: center;
            font-family: 'Poppins-Regular', 'sans-serif';
            line-height: 30px;
        }

        #start-button {
            background: #22C674 0% 0% no-repeat padding-box;
            margin: 5px;
            padding: 5px;
            margin-bottom: 10px;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            justify-content: center;
            align-items: center;
        }

        #stop-button {
            background: #FF4343 0% 0% no-repeat padding-box;
            margin: 5px;
            padding: 5px;
            margin-bottom: 10px;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            justify-content: center;
            align-items: center;
        }

        #confirm-button1 {
            margin: 5px;
            padding: 5px;
            margin-bottom: 10px;
            border: 2px solid #22C674;
            background: #FFFFFF 0% 0% no-repeat padding-box;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            justify-content: center;
            align-items: center;
        }

        @font-face {
            font-family: Poppins-Regular;
            src: url('./fonts/Poppins-Regular.ttf') format('truetype');
        }

    </style>
</head>
<body>

<div id="manual-measuring-panel" style="display: none; touch-action: none;">
    <div class="triple-options-panel" style="display:flex; flex-direction: row;">
        <div onclick="deleteFarm();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 18px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="trash-2.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Delete</span>
        </div>
        <div onclick="undo();" style="width: 33.3%; justify-content: center; align-items: center">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-ccw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Undo</span>
        </div>
        <div onclick="redo();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-cw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Redo</span>
        </div>
    </div>
    <div onclick="confirm();" class="green-button-with-text">
        <span style="color: #FFFFFF; font-family: 'Poppins-Regular','sans-serif';"> Confirm </span>
    </div>
</div>

<div id="gps-panel" style="display: none; touch-action: none;">
    <div class="triple-options-panel" style="display:flex; flex-direction: row;">
        <div onclick="deleteFarm();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 18px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="trash-2.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Delete</span>
        </div>
        <div onclick="undo();" style="width: 33.3%; justify-content: center; align-items: center">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-ccw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Undo</span>
        </div>
        <div onclick="redo();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-cw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Redo</span>
        </div>
    </div>
    <div style="display:flex; flex-direction: row;">
        <div onclick="onClickPinLocation()" id="pin-location-button">
            <span style="color: #FFFFFF; font-family: 'Poppins-Regular','sans-serif';"> Pin Location </span>
        </div>
        <div onclick="confirm();" id="confirm-button"
             style="display: flex; flex: 1; justify-content: center; align-items: center">
            <span style="color: #22C674; font-family: 'Poppins-Regular','sans-serif';"> Confirm </span>
        </div>
    </div>
</div>

<div id="auto-gps-panel" style="display: none; touch-action: none;">
    <div class="triple-options-panel" style="display:flex; flex-direction: row;">
        <div onclick="deleteFarm();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 18px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="trash-2.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Delete</span>
        </div>
        <div onclick="undo();" style="width: 33.3%; justify-content: center; align-items: center">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-ccw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Undo</span>
        </div>
        <div onclick="redo();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-cw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Redo</span>
        </div>
    </div>
    <div style="display:flex; flex-direction: row;">
        <div onclick="onClickStart()" id="start-button" style="display: block;">
            <span style="color: #FFFFFF; font-family: 'Poppins-Regular','sans-serif';"> Start </span>
        </div>
        <div onclick="onClickStop()" id="stop-button" style="display: none;">
            <span style="color: #FFFFFF; font-family: 'Poppins-Regular','sans-serif';"> Stop </span>
        </div>
        <div onclick="confirm();" id="confirm-button1">
            <span style="color: #22C674; font-family: 'Poppins-Regular','sans-serif';"> Confirm </span>
        </div>
    </div>
</div>

<div id="choose-panel" style="display: block; touch-action: none;">
    <div style="border-bottom: 1px solid #F0F0F1; padding-left: 16px; display: block; margin: 2px;">
        <span style="color: #20B46D;  font-family: 'Poppins-Regular','sans-serif';"> Choose Mode </span>
    </div>
    <div onclick="addManualMeasuring()"
         style="border-bottom: 1px solid #F0F0F1; padding-left: 16px; display: block; margin: 2px; vertical-align:middle;">
        <img style="margin-right:2px; vertical-align:middle; width: 16px; height: 17px; background: 0% 0% no-repeat padding-box; opacity: 1;"
             src="git-branch.svg">
        <span style="vertical-align:middle; color: #707070; font-family: 'Poppins-Regular','sans-serif';"> Manual measuring </span>
    </div>
    <div onclick="addGpsMeasuring()" style="border-bottom: 1px solid #F0F0F1; padding-left: 16px; display: block;">
        <img style="margin-right:2px; vertical-align:middle;width: 16px; height: 17px; background: 0% 0% no-repeat padding-box; opacity: 1;"
             src="crosshair.svg">
        <span style="vertical-align:middle; color: #707070; font-family: 'Poppins-Regular','sans-serif';"> GPS measuring </span>
    </div>
    <div onclick="addAutoGpsMeasuring()" style="padding-left: 16px; display: block;">
        <img style="margin-right:2px; vertical-align:middle; width: 16px; height: 17px; background: 0% 0% no-repeat padding-box; opacity: 1;"
             src="map-pin.svg">
        <span style="vertical-align:middle; color: #707070; font-family: 'Poppins-Regular','sans-serif';"> Auto GPS measuring </span>
    </div>
</div>

<div id="map"></div>

<script>

    var poly, farmPolygon;
    var map, infoWindow, markerCurrentLocation;
    var path;
    var undoArray = [];
    var redoArray = [];
    let isStarted = false;
    let isDeleting = false;
    let isInserting = false;
    let tempDeleteArray = [];
    let tempSetArray = [];
    let plotsArray = [];
    let plotsArrayIncrementation = 0;
    let setAtFalse = false;
    let dragging = false;
    let isDraggingUndo = false;     //only for undo option
    let isDeletingUndo = false;     //only for undo option

    const MAP_STYLE = [
        {
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#E5E5E5"
                }
            ]
        },
        {
            "elementType": "labels.icon",
            "stylers": [
                {
                    "visibility": "off"
                }
            ]
        },
        {
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#616161"
                }
            ]
        },
        {
            "elementType": "labels.text.stroke",
            "stylers": [
                {
                    "color": "#f5f5f5"
                }
            ]
        },
        {
            "featureType": "administrative.land_parcel",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#bdbdbd"
                }
            ]
        },
        {
            "featureType": "poi",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#eeeeee"
                }
            ]
        },
        {
            "featureType": "poi",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#757575"
                }
            ]
        },
        {
            "featureType": "poi.park",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#e5e5e5"
                }
            ]
        },
        {
            "featureType": "poi.park",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#9e9e9e"
                }
            ]
        },
        {
            "featureType": "road",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#ffffff"
                }
            ]
        },
        {
            "featureType": "road.arterial",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#757575"
                }
            ]
        },
        {
            "featureType": "road.highway",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#dadada"
                }
            ]
        },
        {
            "featureType": "road.highway",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#616161"
                }
            ]
        },
        {
            "featureType": "road.local",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#9e9e9e"
                }
            ]
        },
        {
            "featureType": "transit.line",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#e5e5e5"
                }
            ]
        },
        {
            "featureType": "transit.station",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#eeeeee"
                }
            ]
        },
        {
            "featureType": "water",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#c9c9c9"
                }
            ]
        },
        {
            "featureType": "water",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#9e9e9e"
                }
            ]
        }
    ];

    function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
            zoom: 13,
            center: {lat: 6.9253, lng: 79.8613123},
            disableDefaultUI: true,
            styles: MAP_STYLE,
            mapTypeId: 'satellite'
        });

        let farmCords = [];

        if (navigator.appVersion.includes('Android')) {
            document.addEventListener("message", function (data) {
                if (data.data.includes("SENZMATEAGRO")) {
                    let splitArray = data.data.split("SENZMATEAGRO");
                    currentFarm = JSON.parse(splitArray[0]);
                    currentFarm["coordinates"] = currentFarm.coordinates.map(function (item) {
                        return {
                            lat: item.latitude,
                            lng: item.longitude
                        };
                    });
                    addFarmPolygon(currentFarm);
                    getCenterOfFarm(currentFarm);
                    let plots = JSON.parse(splitArray[1]);
                    plots.map(function (item) {
                        item["coordinates"] = item.coordinates.map(function (e) {
                            return {lat: e.latitude, lng: e.longitude}
                        });
                    });
                    plots.forEach(addPlotPolygon);
                    JSON.parse(splitArray[2]).forEach(addValve);
                } else if (JSON.parse(data.data).name === 'GPS') {
                    let gpsPosition = JSON.parse(data.data);
                    addGpsPositionToPolygon(gpsPosition);
                } else if (JSON.parse(data.data).name === 'current location') {
                    let currentPosition = JSON.parse(data.data);
                    showPosition(currentPosition);
                } else {
                    showError(JSON.parse(data.data).message);
                }
            });
        } else {
            window.addEventListener("message", function (data) {
                if (data.data.includes("SENZMATEAGRO")) {
                    let splitArray = data.data.split("SENZMATEAGRO");
                    currentFarm = JSON.parse(splitArray[0]);
                    currentFarm["coordinates"] = currentFarm.coordinates.map(function (item) {
                        return {
                            lat: item.latitude,
                            lng: item.longitude
                        };
                    });
                    addFarmPolygon(currentFarm);
                    getCenterOfFarm(currentFarm);
                    let plots = JSON.parse(splitArray[1]);
                    plots.map(function (item) {
                        item["coordinates"] = item.coordinates.map(function (e) {
                            return {lat: e.latitude, lng: e.longitude}
                        });
                    });
                    plots.forEach(addPlotPolygon);
                    JSON.parse(splitArray[2]).forEach(addValve);
                } else if (JSON.parse(data.data).name === 'GPS') {
                    let gpsPosition = JSON.parse(data.data);
                    addGpsPositionToPolygon(gpsPosition);
                } else if (JSON.parse(data.data).name === 'current location') {
                    let currentPosition = JSON.parse(data.data);
                    showPosition(currentPosition);
                } else {
                    showError(JSON.parse(data.data).message);
                }
            });
        }

        poly = new google.maps.Polygon({
            strokeOpacity: 1,
            fillColor: '#22C6877B',
            strokeColor: '#A3A3A3',
            strokeWeight: 3,
            editable: true,
            draggable: true,
            suppressUndo: true, // added for hiding undo button
        });
        poly.setMap(map);

        farmPolygon = new google.maps.Polygon({
            fillColor: '#22C6877B',
            fillOpacity: 0.35,
            strokeColor: '#22C687',
            strokeOpacity: 1.0,
            strokeWeight: 3,
            clickable: false
        });
        farmPolygon.setMap(map);

        markerCurrentLocation = new google.maps.Marker({
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 7,
                fillColor: '#4285F4',
                fillOpacity: 1,
                strokeColor: '#ABC3E7',
                strokeWeight: 4,
                strokeOpacity: 1
            },
            map: map
        });

        infoWindow = new google.maps.InfoWindow;

        addFarmButton(map);

        google.maps.event.addListener(poly, 'dragstart', function (event) {
            dragging = true;
            tempSetArray = [];
            for (let i = 0; i < poly.getPath().length; i++) {
                tempSetArray.push(poly.getPath().getAt(i));
            }
            const elem = ['drag'];
            undoArray.push(elem);
        });

        google.maps.event.addListener(poly, 'dragend', function (event) {
            let isInside = true;
            for (let i = 0; i < poly.getPath().length; i++) {
                const currentCoordinates = poly.getPath().getAt(i);
                isInside = google.maps.geometry.poly.containsLocation(currentCoordinates, farmPolygon);
                if (!isInside) break;
            }

            if (!isInside) {
                window.ReactNativeWebView.postMessage('A Plot should be inside the farm boundary and outside the existing plot boundaries');
                isDraggingUndo = true;
                poly.getPath().clear();
                for (let i = 0; i < tempSetArray.length; i++) {
                    poly.getPath().push(tempSetArray[i]);
                }
                tempSetArray = [];
                isDraggingUndo = false;
                undoArray.pop();
            } else {
                const isIntersectionValue = checkIntersection();
                if (isIntersectionValue === 2) {
                    window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                    isDraggingUndo = true;
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray.length; i++) {
                        poly.getPath().push(tempSetArray[i]);
                    }
                    tempSetArray = [];
                    isDraggingUndo = false;
                    undoArray.pop();
                } else if (isIntersectionValue) {
                    window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                    isDraggingUndo = true;
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray.length; i++) {
                        poly.getPath().push(tempSetArray[i]);
                    }
                    tempSetArray = [];
                    isDraggingUndo = false;
                    undoArray.pop();
                }
            }
            dragging = false;
        });

        //https://stackoverflow.com/questions/25931148/google-map-api-v3-adding-custom-undo-redo-function-for-edited-polygon
        google.maps.event.addListener(poly, 'dblclick', function (e) {
            poly.getPath().removeAt(e.vertex);
        });

        google.maps.event.addListener(poly.getPath(), 'remove_at', function (index, removedPosition) {
            if (!isInserting) {
                if (!isDraggingUndo) {
                    if (isDeleting) {
                        tempDeleteArray.push(removedPosition);
                    } else {
                        const elem = ['remove', index, removedPosition];
                        undoArray.push(elem);
                    }
                }
            }
        });

        google.maps.event.addListener(poly.getPath(), 'insert_at', function (index) {
            if (!isInserting) {
                if (!isDraggingUndo && !isDeletingUndo) {
                    const insertedCoordinates = poly.getPath().getAt(index);
                    var elem = ['insert', index, insertedCoordinates];
                    undoArray.push(elem);
                }
            }
        });

        google.maps.event.addListener(poly.getPath(), 'set_at', function (index, previous) {
            if (!dragging) {
                const currentCoordinates = poly.getPath().getAt(index);
                let isInside = google.maps.geometry.poly.containsLocation(currentCoordinates, farmPolygon);
                let isInsidePlot = false;
                for (let i = 0; i < plotsArrayIncrementation; i++) {
                    isInsidePlot = google.maps.geometry.poly.containsLocation(currentCoordinates, plotsArray[i]);
                    if (isInsidePlot) break;
                }
                if (isInside && !isInsidePlot) {
                    const isIntersectionValue = checkIntersection();
                    if (isIntersectionValue === 2) {
                        setAtFalse = true;

                        window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                        // poly.getPath().setAt(index, previous);
                        poly.getPath().removeAt(index)

                        setAtFalse = false;
                    } else if (isIntersectionValue) {
                        setAtFalse = true;

                        window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                        // poly.getPath().setAt(index, previous);
                        poly.getPath().removeAt(index)
                        s
                        setAtFalse = false;
                    } else if (!setAtFalse) {
                        window.ReactNativeWebView.postMessage('reset');
                        var elem = ['edit', index, previous, currentCoordinates];
                        poly.getPath().removeAt(index)

                        undoArray.push(elem);
                    }

                } else {
                    setAtFalse = true;
                    window.ReactNativeWebView.postMessage('A Plot should be inside the farm boundary and outside the existing plot boundaries');
                    // poly.getPath().setAt(index, previous);
                    setAtFalse = false;
                }
            }
        });

    }

    function checkIntersection() {
        let coordinates = '';

        let geometryFactory;
        let bermudaPolygon;
        let anotherPolygon;
        let intersection;

        let tempPoly = new google.maps.Polygon({
            strokeOpacity: 1,
            fillColor: '#22C6877B',
            strokeColor: '#A3A3A3',
            strokeWeight: 3,
            editable: true,
            draggable: true,
            suppressUndo: true, // added for hiding undo button
        });

        if (poly.getPath().length > 2) {


            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, poly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    return 2;
                }

                if (coordinates.length > 0) break;

            }

        } else if (poly.getPath().length > 1) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(poly.getPath().getAt(1));
            tempPoly.getPath().push(new google.maps.LatLng(poly.getPath().getAt(1).lat() + 0.00000001, poly.getPath().getAt(1).lng() + 0.000000001));

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        } else if (poly.getPath().length > 0) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(new google.maps.LatLng(poly.getPath().getAt(0).lat() + 0.00000001, poly.getPath().getAt(0).lng() + 0.000000001));
            tempPoly.getPath().push(new google.maps.LatLng(poly.getPath().getAt(0).lat() - 0.00000001, poly.getPath().getAt(0).lng() + 0.000000001));

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        }

        return coordinates.length > 0;
    }

    function checkIntersectionInsert(eventLatLng) {

        let coordinates = '';

        let geometryFactory;
        let bermudaPolygon;
        let anotherPolygon;
        let intersection;

        let tempPoly = new google.maps.Polygon({
            strokeOpacity: 1,
            fillColor: '#22C6877B',
            strokeColor: '#A3A3A3',
            strokeWeight: 3,
            editable: true,
            draggable: true,
            suppressUndo: true, // added for hiding undo button
        });

        if (poly.getPath().length > 2) {

            isInserting = true;
            poly.getPath().push(eventLatLng);

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, poly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    poly.getPath().removeAt(poly.getPath().length - 1);
                    isInserting = false;
                    return 2;
                }

                if (coordinates.length > 0) {
                    poly.getPath().removeAt(poly.getPath().length - 1);
                    isInserting = false;
                    return true;
                }
            }

            poly.getPath().removeAt(poly.getPath().length - 1);
            isInserting = false;

        } else if (poly.getPath().length > 1) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(poly.getPath().getAt(1));
            tempPoly.getPath().push(eventLatLng);

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        } else if (poly.getPath().length > 0) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(eventLatLng);
            tempPoly.getPath().push(new google.maps.LatLng(eventLatLng.lat() + 0.00000001, eventLatLng.lng() + 0.000000001));

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);

                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        }


        return coordinates.length > 0;
    }

    function createJstsPolygon(geometryFactory, polygon) {
        var path = polygon.getPath();
        var coordinates = path.getArray().map(function name(coord) {
            return new jsts.geom.Coordinate(coord.lat(), coord.lng());
        });
        coordinates.push(coordinates[0]);
        var shell = geometryFactory.createLinearRing(coordinates);
        return geometryFactory.createPolygon(shell);
    }

    function addFarmPolygon(farm) {
        const farmPath = farmPolygon.getPath();
        for (let i = 0; i < farm.coordinates.length; i++) {
            let pos = new google.maps.LatLng(farm.coordinates[i].lat, farm.coordinates[i].lng);
            farmPath.push(pos);
        }
    }

    function addPlotPolygon(plot) {
        plotsArray[plotsArrayIncrementation] = new google.maps.Polygon({
            paths: plot.coordinates,
            fillColor: '#22C6877B',
            fillOpacity: 0.35,
            strokeColor: '#22C687',
            strokeOpacity: 1.0,
            strokeWeight: 3,
            clickable: false
        });
        plotsArray[plotsArrayIncrementation].setMap(map);
        plotsArrayIncrementation++;
    }

    function getCenterOfFarm(farm) {
        let bounds = new google.maps.LatLngBounds();
        for (let i = 0; i < farm.coordinates.length; i++) {
            bounds.extend(farm.coordinates[i]);
        }
        map.setCenter(bounds.getCenter());
        map.fitBounds(bounds);
    }

    function addValve(valve) {
        //TODO change marker icon
        new google.maps.Marker({
            position: valve.coordinate,
            icon: {
                url: './valve.svg', // url
            },
            map: map
        });
    }

    function addManualMeasuring() {
        poly.getPath().clear();
        undoArray = [];
        redoArray = [];
        document.getElementById('choose-panel').style.display = 'none';
        document.getElementById('manual-measuring-panel').style.display = 'block';
        document.getElementById('gps-panel').style.display = 'none';
        document.getElementById('auto-gps-panel').style.display = 'none';
        map.addListener('click', addNewCoordinate);
        document.getElementById('controlDiv').style.display = 'block';
        document.getElementById('plusSign').style.backgroundImage = 'url(./git-branch.svg)';
    }

    function addGpsMeasuring() {
        poly.getPath().clear();
        undoArray = [];
        redoArray = [];
        google.maps.event.clearListeners(map, 'click');
        document.getElementById('choose-panel').style.display = 'none';
        document.getElementById('gps-panel').style.display = 'block';
        document.getElementById('manual-measuring-panel').style.display = 'none';
        document.getElementById('auto-gps-panel').style.display = 'none';
        document.getElementById('controlDiv').style.display = 'block';
        document.getElementById('plusSign').style.backgroundImage = 'url(./crosshair.svg)';
    }

    function addAutoGpsMeasuring() {
        poly.getPath().clear();
        undoArray = [];
        redoArray = [];
        google.maps.event.clearListeners(map, 'click');
        document.getElementById('choose-panel').style.display = 'none';
        document.getElementById('auto-gps-panel').style.display = 'block';
        document.getElementById('manual-measuring-panel').style.display = 'none';
        document.getElementById('gps-panel').style.display = 'none';
        document.getElementById('controlDiv').style.display = 'block';
        document.getElementById('plusSign').style.backgroundImage = 'url(./map-pin.svg)';
    }

    function addNewCoordinate(event) {
        path = poly.getPath();
        let isInside = google.maps.geometry.poly.containsLocation(event.latLng, farmPolygon);
        let isInsidePlot = false;
        for (let i = 0; i < plotsArrayIncrementation; i++) {
            isInsidePlot = google.maps.geometry.poly.containsLocation(event.latLng, plotsArray[i]);
            if (isInsidePlot) break;
        }

        if (isInside && !isInsidePlot) {
            const isIntersectionValue = checkIntersectionInsert(event.latLng);
            if (isIntersectionValue === 2) {
                window.ReactNativeWebView.postMessage('Plots lines should not intersect with each other');
            } else if (isIntersectionValue) {
                window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
            } else {
                path.push(event.latLng);
                window.ReactNativeWebView.postMessage('reset');
            }
        } else window.ReactNativeWebView.postMessage('A Plot should be inside the farm boundary and outside the existing plot boundaries');
    }

    function onClickPinLocation() {
        window.ReactNativeWebView.postMessage('Geolocation GPS permission');
    }

    async function onClickStart() {
        document.getElementById('start-button').style.display = 'none';
        document.getElementById('stop-button').style.display = 'block';
        isStarted = true;
        while (isStarted) {
            window.ReactNativeWebView.postMessage('Geolocation GPS permission');
            await sleep(60000);
        }
    }

    async function onClickStop() {
        isStarted = false;
        document.getElementById('start-button').style.display = 'block';
        document.getElementById('stop-button').style.display = 'none';
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function addGpsPositionToPolygon(position) {
        let temp = new google.maps.LatLng(position.lat, position.lng);
        path = poly.getPath();
        path.push(temp);
    }

    function undo() {
        if (undoArray.length > 0) {
            var temp = undoArray.pop();
            switch (temp[0]) {
                case 'insert' :
                    poly.getPath().removeAt(temp[1]);
                    undoArray.pop();
                    redoArray.push(temp);
                    break;
                case 'remove' :
                    poly.getPath().insertAt(temp[1], temp[2]);
                    undoArray.pop();
                    redoArray.push(temp);
                    break;
                case 'edit' :
                    poly.getPath().setAt(temp[1], temp[2]);
                    undoArray.pop();
                    redoArray.push(temp);
                    break;
                case 'delete' :
                    isDeletingUndo = true;
                    path = poly.getPath();
                    for (let i = 0; i < tempDeleteArray.length; i++) {
                        path.push(tempDeleteArray[i]);
                    }
                    tempDeleteArray = [];
                    redoArray.push(temp);
                    isDeletingUndo = false;
                    break;
                case 'drag' :
                    isDraggingUndo = true;
                    const tempSetArray2 = tempSetArray;
                    tempSetArray = [];
                    for (let i = 0; i < poly.getPath().length; i++) {
                        tempSetArray.push(poly.getPath().getAt(i));
                    }
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray2.length; i++) {
                        poly.getPath().push(tempSetArray2[i]);
                    }
                    redoArray.push(temp);
                    isDraggingUndo = false;
                    break;
                default:
                    break;
            }
        }
    }

    function redo() {
        if (redoArray.length > 0) {
            var temp = redoArray.pop();
            switch (temp[0]) {
                case 'insert' :
                    poly.getPath().insertAt(temp[1], temp[2]);
                    break;
                case 'remove' :
                    poly.getPath().removeAt(temp[1]);
                    break;
                case 'edit' :
                    poly.getPath().setAt(temp[1], temp[3]);
                    break;
                case 'delete' :
                    isDeleting = true;
                    const elem = ['delete'];
                    undoArray.push(elem);
                    poly.getPath().clear();
                    isDeleting = false;
                    break;
                case 'drag' :
                    isDraggingUndo = true;
                    let tempSetArray2 = tempSetArray;
                    tempSetArray = [];
                    for (let i = 0; i < poly.getPath().length; i++) {
                        tempSetArray.push(poly.getPath().getAt(i));
                    }
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray2.length; i++) {
                        poly.getPath().push(tempSetArray2[i]);
                    }
                    undoArray.push(temp);
                    isDraggingUndo = false;
                    break;
                default:
                    break;
            }
        }
    }

    function deleteFarm() {
        isDeleting = true;
        const elem = ['delete'];
        undoArray.push(elem);
        poly.getPath().clear();
        isDeleting = false;
    }

    function confirm() {
        var polygonCoordinates = [];

        if (poly.getPath().getLength() >= 3) {
            for (var i = 0; i < poly.getPath().getLength(); i++) {
                var xy = poly.getPath().getAt(i);
                coordinatesObj = {latitude: xy.lat(), longitude: xy.lng()}
                //polygonCoordinates = polygonCoordinates + ',' +  xy.lat() + ',' + xy.lng();
                polygonCoordinates.push(coordinatesObj);
            }
            //window.ReactNativeWebView.postMessage(poly.getPath().getLength())
            window.ReactNativeWebView.postMessage(JSON.stringify(polygonCoordinates))
        } else {
            window.ReactNativeWebView.postMessage('A Plot should consist of at least 3 points')
        }
    }

    function visiblePanel() {
        if (document.getElementById('choose-panel').style.display === 'none') {
            document.getElementById('choose-panel').style.display = 'block';
            document.getElementById('controlDiv').style.display = 'none';
            google.maps.event.clearListeners(map, 'click');
        } else {
            document.getElementById('choose-panel').style.display = 'none';
            document.getElementById('manual-measuring-panel').style.display = 'none';
            document.getElementById('gps-panel').style.display = 'none';
            document.getElementById('auto-gps-panel').style.display = 'none';
            document.getElementById('controlDiv').style.display = 'block';
        }
    }

    function showPosition(position) {
        let pos = new google.maps.LatLng(position.lat, position.lng);
        markerCurrentLocation.setPosition(pos);
        map.setCenter(pos);
    }

    function showError(error) {
        if (error.includes('Geolocation is supported and method call is not successful'))
            window.ReactNativeWebView.postMessage("Location permissions not granted");
        else
            window.ReactNativeWebView.postMessage(error);
    }

    function addFarmButton(map) {
        let controlDiv = document.createElement('div');
        controlDiv.setAttribute("id", "controlDiv");

        let addFarm = document.createElement('button');
        addFarm.style.backgroundColor = '#FFFFFF';
        // addFarm.style.background = '#FFFFFF 0% 0% no-repeat padding-box';
        addFarm.style.border = 'none';
        addFarm.style.outline = 'none';
        addFarm.style.width = '24px';
        addFarm.style.height = '24px';
        addFarm.style.borderRadius = '5px';
        addFarm.style.boxShadow = '0px 2px 2px #00000029';
        addFarm.style.marginRight = '10px';
        addFarm.style.marginTop = '15px';
        addFarm.style.zIndex = '6';
        addFarm.style.padding = '0';
        addFarm.title = 'Add Farm';
        addFarm.style.opacity = '1';
        controlDiv.appendChild(addFarm);

        let plusSign = document.createElement('div');
        plusSign.setAttribute("id", "plusSign");
        plusSign.style.width = '25px';
        plusSign.style.height = '25px';
        plusSign.style.backgroundSize = '15px 15px';
        plusSign.style.backgroundPosition = '5px 5px';
        plusSign.style.backgroundRepeat = 'no-repeat';
        addFarm.appendChild(plusSign);

        addFarm.addEventListener('click', visiblePanel);
        controlDiv.index = 1;
        controlDiv.style.display = 'none';
        map.controls[google.maps.ControlPosition.RIGHT_TOP].push(controlDiv);

    }


</script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA9uKFEIqgW63abTdvYTqb3gS6r-60FRpI&libraries=places&callback=initMap&libraries=drawing"
        async defer></script>
<script src="https://cdn.rawgit.com/bjornharrtell/jsts/gh-pages/1.1.2/jsts.min.js"></script>

</body>
</html>
