<!DOCTYPE html>
<html>
<head>
    <title>Simple Map</title>
    <meta name="viewport" content="initial-scale=1.0">
    <meta charset="utf-8">
    <style>
        #map {
            height: 100%;
        / / padding-bottom: 25 px;
        / / added to hide google copyright info in the map
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #manual-measuring-panel {
            position: absolute;
            bottom: 0px;
            left: 0px;
            right: 0px;
            z-index: 5;
            padding: 5px;
            background-color: #fff;
            border-radius: 15px 15px 15px 15px;
            text-align: center;
            font-family: 'Roboto', 'sans-serif';
            line-height: 30px;
        }

        .triple-options-panel {
            z-index: 5;
            padding: 5px;
            text-align: center;
            font-family: 'Roboto', 'sans-serif';
            line-height: 30px;
        }

        .green-button-with-text {
            background: #22C674 0% 0% no-repeat padding-box;
            padding: 5px;
            margin-left: 16px;
            margin-right: 16px;
            margin-bottom: 10px;
            border-radius: 4px;
            line-height: 30px;
            display: flex;
            flex: 1;
            flex-direction: row;
            justify-content: center;
            align-items: center;
        }

        @font-face {
            font-family: Poppins-Regular;
            src: url('./fonts/Poppins-Regular.ttf') format('truetype');
        }

    </style>
</head>
<body>

<div id="manual-measuring-panel" style="display: block; touch-action: none;">
    <div class="triple-options-panel" style="display:flex; flex-direction: row;">
        <div onclick="deleteFarm();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 18px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="trash-2.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Delete</span>
        </div>
        <div onclick="undo();" style="width: 33.3%; justify-content: center; align-items: center">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-ccw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Undo</span>
        </div>
        <div onclick="redo();" style="width: 33.3%">
            <img style="margin-right:auto; margin-left:auto; display: block; width: 20px; height: 20px; background: 0% 0% no-repeat padding-box; opacity: 1;"
                 src="rotate-cw.svg">
            <span style="vertical-align:middle; color: #757575; font-family: 'Poppins-Regular','sans-serif';"> Redo</span>
        </div>
    </div>
    <div onclick="confirm();" class="green-button-with-text">
        <span style="color: #FFFFFF; font-family: 'Poppins-Regular','sans-serif';"> Next </span>
    </div>
</div>

<div id="map"></div>

<script>

    var poly, farmPolygon;
    var map, infoWindow, markerCurrentLocation;
    var path;
    var undoArray = [];
    var redoArray = [];
    let currentPlot = {};
    let currentFarm = {};
    let isDeleting = false;
    let isInserting = false;
    let isExistingPlot = false;
    let tempDeleteArray = [];
    let tempSetArray = [];
    let plotsArray = [];
    let plotsArrayIncrementation = 0;
    let setAtFalse = false;
    let dragging = false;
    let isDraggingUndo = false;     //only for undo option
    let isDeletingUndo = false;     //only for undo option

    const MAP_STYLE = [
        {
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#E5E5E5"
                }
            ]
        },
        {
            "elementType": "labels.icon",
            "stylers": [
                {
                    "visibility": "off"
                }
            ]
        },
        {
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#616161"
                }
            ]
        },
        {
            "elementType": "labels.text.stroke",
            "stylers": [
                {
                    "color": "#f5f5f5"
                }
            ]
        },
        {
            "featureType": "administrative.land_parcel",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#bdbdbd"
                }
            ]
        },
        {
            "featureType": "poi",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#eeeeee"
                }
            ]
        },
        {
            "featureType": "poi",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#757575"
                }
            ]
        },
        {
            "featureType": "poi.park",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#e5e5e5"
                }
            ]
        },
        {
            "featureType": "poi.park",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#9e9e9e"
                }
            ]
        },
        {
            "featureType": "road",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#ffffff"
                }
            ]
        },
        {
            "featureType": "road.arterial",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#757575"
                }
            ]
        },
        {
            "featureType": "road.highway",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#dadada"
                }
            ]
        },
        {
            "featureType": "road.highway",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#616161"
                }
            ]
        },
        {
            "featureType": "road.local",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#9e9e9e"
                }
            ]
        },
        {
            "featureType": "transit.line",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#e5e5e5"
                }
            ]
        },
        {
            "featureType": "transit.station",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#eeeeee"
                }
            ]
        },
        {
            "featureType": "water",
            "elementType": "geometry",
            "stylers": [
                {
                    "color": "#c9c9c9"
                }
            ]
        },
        {
            "featureType": "water",
            "elementType": "labels.text.fill",
            "stylers": [
                {
                    "color": "#9e9e9e"
                }
            ]
        }
    ];

    function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
            zoom: 13,
            center: {lat: 6.9253, lng: 79.8613123},
            disableDefaultUI: true,
            styles: MAP_STYLE,
            mapTypeId: 'satellite'
        });

        if (navigator.appVersion.includes('Android')) {
            document.addEventListener("message", function (data) {
                if (data.data.includes("SENZMATEAGRO")) {
                    let splitArray = data.data.split("SENZMATEAGRO");
                    currentFarm = JSON.parse(splitArray[0]);
                    currentFarm["coordinates"] = currentFarm.coordinates.map(function (item) {
                        return {
                            lat: item.latitude,
                            lng: item.longitude
                        };
                    });
                    addFarmPolygon(currentFarm);    // draw the farm polygon
                    currentPlot = JSON.parse(splitArray[1]);
                    getCenterOfFarm(currentFarm);
                    let plots = JSON.parse(splitArray[2]);
                    plots.map(function (item) {
                        item["coordinates"] = item.coordinates.map(function (e) {
                            return {lat: e.latitude, lng: e.longitude}
                        });
                    });
                    plots.forEach(addPlotPolygon);  //// draw the plot polygons
                } else if (JSON.parse(data.data).name === 'current location') {
                    let currentPosition = JSON.parse(data.data);
                    showPosition(currentPosition);
                } else {
                    showError(JSON.parse(data.data).message);
                }
            });
        } else {
            window.addEventListener("message", function (data) {
                if (data.data.includes("SENZMATEAGRO")) {
                    let splitArray = data.data.split("SENZMATEAGRO");
                    currentFarm = JSON.parse(splitArray[0]);
                    currentFarm["coordinates"] = currentFarm.coordinates.map(function (item) {
                        return {
                            lat: item.latitude,
                            lng: item.longitude
                        };
                    });
                    addFarmPolygon(currentFarm);    // draw the farm polygon
                    currentPlot = JSON.parse(splitArray[1]);
                    getCenterOfFarm(currentFarm);
                    let plots = JSON.parse(splitArray[2]);
                    plots.map(function (item) {
                        item["coordinates"] = item.coordinates.map(function (e) {
                            return {lat: e.latitude, lng: e.longitude}
                        });
                    });
                    plots.forEach(addPlotPolygon);  //// draw the plot polygons
                } else if (JSON.parse(data.data).name === 'current location') {
                    let currentPosition = JSON.parse(data.data);
                    showPosition(currentPosition);
                } else {
                    showError(JSON.parse(data.data).message);
                }
            });
        }

        addListenerOnMap();

        poly = new google.maps.Polygon({
            strokeOpacity: 1,
            fillColor: '#22C6877B',
            strokeColor: '#A3A3A3',
            strokeWeight: 3,
            editable: true,
            draggable: true,
            suppressUndo: true, // added for hiding undo button
        });

        poly.setMap(map);

        farmPolygon = new google.maps.Polygon({
            fillColor: '#22C6877B',
            fillOpacity: 0.35,
            strokeColor: '#22C687',
            strokeOpacity: 1.0,
            strokeWeight: 3,
            clickable: false
        });
        farmPolygon.setMap(map);

        markerCurrentLocation = new google.maps.Marker({
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 7,
                fillColor: '#4285F4',
                fillOpacity: 1,
                strokeColor: '#ABC3E7',
                strokeWeight: 4,
                strokeOpacity: 1
            },
            map: map
        });

        infoWindow = new google.maps.InfoWindow;

        addYourLocationButton(map);

        google.maps.event.addListener(poly, 'dragstart', function (event) {
            dragging = true;
            tempSetArray = [];
            for (let i = 0; i < poly.getPath().length; i++) {
                tempSetArray.push(poly.getPath().getAt(i));
            }
            const elem = ['drag'];
            undoArray.push(elem);
        });

        google.maps.event.addListener(poly, 'dragend', function (event) {
            let isInside = true;
            for (let i = 0; i < poly.getPath().length; i++) {
                const currentCoordinates = poly.getPath().getAt(i);
                isInside = google.maps.geometry.poly.containsLocation(currentCoordinates, farmPolygon);
                if (!isInside) break;
            }

            if (!isInside) {
                window.ReactNativeWebView.postMessage('A Plot should be inside the farm boundary and outside the existing plot boundaries');
                isDraggingUndo = true;
                poly.getPath().clear();
                for (let i = 0; i < tempSetArray.length; i++) {
                    poly.getPath().push(tempSetArray[i]);
                }
                tempSetArray = [];
                isDraggingUndo = false;
                undoArray.pop();
            } else {
                const isIntersectionValue = checkIntersection();
                if (isIntersectionValue === 2) {
                    window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                    isDraggingUndo = true;
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray.length; i++) {
                        poly.getPath().push(tempSetArray[i]);
                    }
                    tempSetArray = [];
                    isDraggingUndo = false;
                    undoArray.pop();
                } else if (isIntersectionValue) {
                    window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                    isDraggingUndo = true;
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray.length; i++) {
                        poly.getPath().push(tempSetArray[i]);
                    }
                    tempSetArray = [];
                    isDraggingUndo = false;
                    undoArray.pop();
                }
            }
            dragging = false;
        });

        //https://stackoverflow.com/questions/25931148/google-map-api-v3-adding-custom-undo-redo-function-for-edited-polygon
        google.maps.event.addListener(poly, 'dblclick', function (e) {
            poly.getPath().removeAt(e.vertex);
        });

        google.maps.event.addListener(poly.getPath(), 'remove_at', function (index, removedPosition) {
            if (!isInserting) {
                if (!isDraggingUndo) {
                    if (isDeleting) {
                        tempDeleteArray.push(removedPosition);
                    } else {
                        const elem = ['remove', index, removedPosition]
                        undoArray.push(elem);
                    }
                }
            }
        });

        google.maps.event.addListener(poly.getPath(), 'insert_at', function (index) {
            if (!isInserting) {
                if (!isDraggingUndo && !isDeletingUndo) {
                    if (!isExistingPlot) {
                        const insertedCoordinates = poly.getPath().getAt(index);
                        const elem = ['insert', index, insertedCoordinates];
                        undoArray.push(elem);
                    }
                }
            }
        });

        google.maps.event.addListener(poly.getPath(), 'set_at', function (index, previous) {
            if (!dragging) {
                const currentCoordinates = poly.getPath().getAt(index);
                let isInside = google.maps.geometry.poly.containsLocation(currentCoordinates, farmPolygon);
                let isInsidePlot = false;
                for (let i = 0; i < plotsArrayIncrementation; i++) {
                    isInsidePlot = google.maps.geometry.poly.containsLocation(currentCoordinates, plotsArray[i]);
                    if (isInsidePlot) break;
                }
                if (isInside && !isInsidePlot) {
                    const isIntersectionValue = checkIntersection();
                    if (isIntersectionValue === 2) {
                        setAtFalse = true;
                        window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                        // poly.getPath().setAt(index, previous);
                        poly.getPath().removeAt(index)

                        setAtFalse = false;
                    } else if (isIntersectionValue) {
                        setAtFalse = true;
                        window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
                        // poly.getPath().setAt(index, previous);
                        poly.getPath().removeAt(index)

                        setAtFalse = false;
                    } else if (!setAtFalse) {
                        window.ReactNativeWebView.postMessage('reset');
                        const elem = ['edit', index, previous, currentCoordinates];
                        undoArray.push(elem);
                    }

                } else {
                    setAtFalse = true;
                    window.ReactNativeWebView.postMessage('A Plot should be inside the farm boundary and outside the existing plot boundaries');
                    // poly.getPath().setAt(index, previous);
                    poly.getPath().removeAt(index)

                    setAtFalse = false;
                }
            }
        });

    }

    function checkIntersection() {
        let coordinates = '';

        let geometryFactory;
        let bermudaPolygon;
        let anotherPolygon;
        let intersection;

        let tempPoly = new google.maps.Polygon({
            strokeOpacity: 1,
            fillColor: '#22C6877B',
            strokeColor: '#A3A3A3',
            strokeWeight: 3,
            editable: true,
            draggable: true,
            suppressUndo: true, // added for hiding undo button
        });

        if (poly.getPath().length > 2) {

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, poly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    return 2;
                }

                if (coordinates.length > 0) break;

            }

        } else if (poly.getPath().length > 1) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(poly.getPath().getAt(1));
            tempPoly.getPath().push(new google.maps.LatLng(poly.getPath().getAt(1).lat() + 0.00000001, poly.getPath().getAt(1).lng() + 0.000000001));

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        } else if (poly.getPath().length > 0) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(new google.maps.LatLng(poly.getPath().getAt(0).lat() + 0.00000001, poly.getPath().getAt(0).lng() + 0.000000001));
            tempPoly.getPath().push(new google.maps.LatLng(poly.getPath().getAt(0).lat() - 0.00000001, poly.getPath().getAt(0).lng() + 0.000000001));

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        }

        return coordinates.length > 0;
    }

    function checkIntersectionInsert(eventLatLng) {

        let coordinates = '';

        let geometryFactory;
        let bermudaPolygon;
        let anotherPolygon;
        let intersection;

        let tempPoly = new google.maps.Polygon({
            strokeOpacity: 1,
            fillColor: '#22C6877B',
            strokeColor: '#A3A3A3',
            strokeWeight: 3,
            editable: true,
            draggable: true,
            suppressUndo: true, // added for hiding undo button
        });

        if (poly.getPath().length > 2) {

            isInserting = true;
            poly.getPath().push(eventLatLng);

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, poly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    poly.getPath().removeAt(poly.getPath().length - 1);
                    isInserting = false;
                    return 2;
                }

                if (coordinates.length > 0) {
                    poly.getPath().removeAt(poly.getPath().length - 1);
                    isInserting = false;
                    return true;
                }
            }

            poly.getPath().removeAt(poly.getPath().length - 1);
            isInserting = false;

        } else if (poly.getPath().length > 1) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(poly.getPath().getAt(1));
            tempPoly.getPath().push(eventLatLng);

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);
                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        } else if (poly.getPath().length > 0) {

            tempPoly.getPath().push(poly.getPath().getAt(0));
            tempPoly.getPath().push(eventLatLng);
            tempPoly.getPath().push(new google.maps.LatLng(eventLatLng.lat() + 0.00000001, eventLatLng.lng() + 0.000000001));

            for (let i = 0; i < plotsArray.length; i++) {

                geometryFactory = new jsts.geom.GeometryFactory();
                bermudaPolygon = createJstsPolygon(geometryFactory, tempPoly);
                anotherPolygon = createJstsPolygon(geometryFactory, plotsArray[i]);

                try {
                    intersection = bermudaPolygon.intersection(anotherPolygon);
                    coordinates = intersection.getCoordinates();
                } catch (e) {
                    console.log(e)
                }

                if (coordinates.length > 0) break;
            }
        }


        return coordinates.length > 0;
    }

    function createJstsPolygon(geometryFactory, polygon) {
        var path = polygon.getPath();
        var coordinates = path.getArray().map(function name(coord) {
            return new jsts.geom.Coordinate(coord.lat(), coord.lng());
        });
        coordinates.push(coordinates[0]);
        var shell = geometryFactory.createLinearRing(coordinates);
        return geometryFactory.createPolygon(shell);
    }

    function addFarmPolygon(farm) {
        const farmPath = farmPolygon.getPath();
        for (let i = 0; i < farm.coordinates.length; i++) {
            let pos = new google.maps.LatLng(farm.coordinates[i].lat, farm.coordinates[i].lng);
            farmPath.push(pos);
        }
    }

    function addPlotPolygon(plot) {
        if (plot.id !== currentPlot.id) {
            plotsArray[plotsArrayIncrementation] = new google.maps.Polygon({
                paths: plot.coordinates,
                fillColor: '#22C6877B',
                fillOpacity: 0.35,
                strokeColor: '#22C687',
                strokeOpacity: 1.0,
                strokeWeight: 3,
                clickable: false
            });
            plotsArray[plotsArrayIncrementation].setMap(map);
            plotsArrayIncrementation++;
        } else if (plot.coordinates[0].lat !== undefined && plot.coordinates[0].lat !== null) {
            isExistingPlot = true;
            for (let i = 0; i < plot.coordinates.length; i++) {
                let temp = new google.maps.LatLng(plot.coordinates[i].lat, plot.coordinates[i].lng);
                path = poly.getPath();
                path.push(temp);
            }
            isExistingPlot = false;
        } else if (plot.coordinates[0].latitude !== undefined && plot.coordinates[0].latitude !== null) {
            isExistingPlot = true;
            for (let i = 0; i < plot.coordinates.length; i++) {
                let temp = new google.maps.LatLng(plot.coordinates[i].latitude, plot.coordinates[i].longitude);
                path = poly.getPath();
                path.push(temp);
            }
            isExistingPlot = false;
        }

    }

    function getCenterOfFarm(farm) {
        let bounds = new google.maps.LatLngBounds();
        for (let i = 0; i < farm.coordinates.length; i++) {
            bounds.extend(farm.coordinates[i]);
        }
        map.setCenter(bounds.getCenter());
        map.fitBounds(bounds);
    }

    function addNewCoordinate(event) {
        path = poly.getPath();
        let isInside = google.maps.geometry.poly.containsLocation(event.latLng, farmPolygon);
        let isInsidePlot = false;
        for (let i = 0; i < plotsArrayIncrementation; i++) {
            isInsidePlot = google.maps.geometry.poly.containsLocation(event.latLng, plotsArray[i]);
            if (isInsidePlot) break;
        }
        if (isInside && !isInsidePlot) {
            const isIntersectionValue = checkIntersectionInsert(event.latLng);
            if (isIntersectionValue === 2) {
                window.ReactNativeWebView.postMessage('Plots lines should not intersect with each other');
            } else if (isIntersectionValue) {
                window.ReactNativeWebView.postMessage('Plots should not intersect with each other');
            } else {
                path.push(event.latLng);
                window.ReactNativeWebView.postMessage('reset');
            }
        } else window.ReactNativeWebView.postMessage('A Plot should be inside the farm boundary and outside the existing plot boundaries');
    }

    function undo() {
        if (undoArray.length > 0) {
            var temp = undoArray.pop();
            switch (temp[0]) {
                case 'insert' :
                    poly.getPath().removeAt(temp[1]);
                    undoArray.pop();
                    redoArray.push(temp);
                    break;
                case 'remove' :
                    poly.getPath().insertAt(temp[1], temp[2]);
                    undoArray.pop();
                    redoArray.push(temp);
                    break;
                case 'edit' :
                    poly.getPath().setAt(temp[1], temp[2]);
                    undoArray.pop();
                    redoArray.push(temp);
                    break;
                case 'delete' :
                    isDeletingUndo = true;
                    path = poly.getPath();
                    for (let i = 0; i < tempDeleteArray.length; i++) {
                        path.push(tempDeleteArray[i]);
                    }
                    tempDeleteArray = [];
                    redoArray.push(temp);
                    isDeletingUndo = false;
                    break;
                case 'drag' :
                    isDraggingUndo = true;
                    const tempSetArray2 = tempSetArray;
                    tempSetArray = [];
                    for (let i = 0; i < poly.getPath().length; i++) {
                        tempSetArray.push(poly.getPath().getAt(i));
                    }
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray2.length; i++) {
                        poly.getPath().push(tempSetArray2[i]);
                    }
                    redoArray.push(temp);
                    isDraggingUndo = false;
                    break;
                default:
                    break;
            }
        }
    }

    function redo() {
        if (redoArray.length > 0) {
            var temp = redoArray.pop();
            switch (temp[0]) {
                case 'insert' :
                    poly.getPath().insertAt(temp[1], temp[2]);
                    break;
                case 'remove' :
                    poly.getPath().removeAt(temp[1]);
                    break;
                case 'edit' :
                    poly.getPath().setAt(temp[1], temp[3]);
                    break;
                case 'delete' :
                    isDeleting = true;
                    const elem = ['delete'];
                    undoArray.push(elem);
                    poly.getPath().clear();
                    isDeleting = false;
                    break;
                case 'drag' :
                    isDraggingUndo = true;
                    let tempSetArray2 = tempSetArray;
                    tempSetArray = [];
                    for (let i = 0; i < poly.getPath().length; i++) {
                        tempSetArray.push(poly.getPath().getAt(i));
                    }
                    poly.getPath().clear();
                    for (let i = 0; i < tempSetArray2.length; i++) {
                        poly.getPath().push(tempSetArray2[i]);
                    }
                    undoArray.push(temp);
                    isDraggingUndo = false;
                    break;
                default:
                    break;
            }
        }
    }

    function deleteFarm() {
        isDeleting = true;
        const elem = ['delete'];
        undoArray.push(elem);
        poly.getPath().clear();
        isDeleting = false;
    }

    function confirm() {
        var polygonCoordinates = [];

        if (poly.getPath().getLength() >= 3) {
            for (var i = 0; i < poly.getPath().getLength(); i++) {
                var xy = poly.getPath().getAt(i);
                const coordinatesObj = {latitude: xy.lat(), longitude: xy.lng()}
                //polygonCoordinates = polygonCoordinates + ',' +  xy.lat() + ',' + xy.lng();
                polygonCoordinates.push(coordinatesObj);
            }
            //window.ReactNativeWebView.postMessage(poly.getPath().getLength())
            window.ReactNativeWebView.postMessage(JSON.stringify(polygonCoordinates))
        } else {
            window.ReactNativeWebView.postMessage('A farm should consist of at least 3 points')
        }
    }

    function getCurrentLoc() {
        window.ReactNativeWebView.postMessage('Geolocation current location permission');
    }

    function addListenerOnMap() {
        map.addListener('click', addNewCoordinate);
    }

    function showPosition(position) {
        let pos = new google.maps.LatLng(position.lat, position.lng);
        markerCurrentLocation.setPosition(pos);
        map.setCenter(pos);
    }

    function showError(error) {
        if (error.includes('Geolocation is supported and method call is not successful'))
            window.ReactNativeWebView.postMessage("Location permissions not granted");
        else
            window.ReactNativeWebView.postMessage(error);
    }

    function addYourLocationButton(map) {
        var controlDiv = document.createElement('div');

        var firstChild = document.createElement('button');
        firstChild.style.backgroundColor = '#fff';
        firstChild.style.border = 'none';
        firstChild.style.outline = 'none';
        firstChild.style.width = '30px';
        firstChild.style.height = '30px';
        firstChild.style.borderRadius = '15px';
        firstChild.style.boxShadow = '0 1px 4px rgba(0,0,0,0.3)';
        firstChild.style.marginRight = '10px';
        firstChild.style.marginBottom = '50px';
        firstChild.style.padding = '0';
        firstChild.title = 'Your Location';
        controlDiv.appendChild(firstChild);

        var secondChild = document.createElement('div');
        secondChild.style.margin = '5px';
        secondChild.style.width = '20px';
        secondChild.style.height = '20px';
        secondChild.style.backgroundImage = 'url(./current_location.svg)';
        secondChild.style.backgroundSize = '20px 20px';
        secondChild.style.backgroundPosition = '5 5';
        secondChild.style.backgroundRepeat = 'no-repeat';
        firstChild.appendChild(secondChild);

        firstChild.addEventListener('click', getCurrentLoc);
        controlDiv.index = 1;
        map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(controlDiv);

    }


</script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA9uKFEIqgW63abTdvYTqb3gS6r-60FRpI&callback=initMap"
        async defer></script>
<script src="https://cdn.rawgit.com/bjornharrtell/jsts/gh-pages/1.1.2/jsts.min.js"></script>
</body>
</html>
